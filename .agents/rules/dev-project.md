---
trigger: always_on
---

Claude Code / laper.ai 的核心方法论（高度浓缩）
1、根目录主md强调任何功能、架构、写法更新必须在工作结束后更新相关目录的子文档。

2、每个文件夹中都有一个极简的架构说明(3行以内)，下面写下每个文件的名字、地位、功能。文件开头声明:一旦我所属的文件夹有所变化，请更新我。

3、每个文件的开头，写下三行极简注释，文件input(依赖外部的什么)、文件ouput(对外提供什么)、文件pos(在系统局部的地位是什么)。并写下，一旦我被更新，务必更新我的开头注释，以及所属的文件夹的md。

示例：用「分形自指结构」驱动 100% Claude Code 开发
它的目标只有一个： 让 AI 在任何尺度下，都清楚自己在系统中的位置，并主动维护一致性。

一、根目录：全局自指点
/README.md

# laper.ai

## 项目约定（强制）

1. 任何功能、架构、写法的变更
   必须在当次工作结束后，同步更新对应目录的子文档（README.md）

2. 文档不是说明书，而是系统的一部分
   文档落后于代码 = 系统已经不一致

3. 如果你发现自己“懒得更新文档”
   说明你已经失控了

> 本项目的结构是分形的：
> 局部即整体，整体即局部

作用说明 这一步的核心不是“提醒”，而是立法： 把“更新文档”从一种好习惯，提升为系统级约束。

二、子目录：局部自指点
/services/README.md

# services

本目录负责：业务逻辑编排
不负责：数据存储、HTTP 协议、任务调度

## 文件说明

- review_service.py
  地位：仓库复核核心逻辑
  职责：判断 / 标记 SKU 是否已复核

- pricing_service.py
  地位：计费规则中枢
  职责：价格计算与策略分发

> 声明：
> 一旦本目录结构或职责发生变化，请更新本文件

这个层级有三个强制特征：

架构说明控制在 3 行以内
每个文件被明确点名、被定位
明确写出：“我需要被更新”
在这种上下文下，Claude 会天然保持克制和一致性。

三、文件级：最小自指单元
/services/review_service.py

"""
input:
- api_name: 服务商标识
- sku: SKU 编码
- WarehouseReviewMarker Repository

output:
- bool: 是否已复核

pos:
- 位于 service 层
- 负责复核判断，不直接访问 ORM

声明：
- 一旦本文件逻辑更新
- 必须同步更新本文件注释
- 并更新所属目录的 README.md
"""